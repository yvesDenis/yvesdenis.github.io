<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IAC on Time-to-Geek</title><link>https://yvesdenis.github.io/tags/iac/</link><description>Recent content in IAC on Time-to-Geek</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 21 Jan 2023 14:17:20 -0500</lastBuildDate><atom:link href="https://yvesdenis.github.io/tags/iac/index.xml" rel="self" type="application/rss+xml"/><item><title>Build serverless system with Pulumi and AWS (Part 3)</title><link>https://yvesdenis.github.io/post/build-serverless-system-part-3-post/</link><pubDate>Sat, 21 Jan 2023 14:17:20 -0500</pubDate><guid>https://yvesdenis.github.io/post/build-serverless-system-part-3-post/</guid><description>Introduction Here we are at the end of our long journey in the cloud which led us to implement our serveless system in synchronous and asynchronous mode.
Our application meets the basic functional requirements to be used in production, however we cannot release a digital system without worrying about security. Security allows us to retain our customers, to assure them of the protection and anonymity of their data which passes through our application.</description></item><item><title>Build serverless system with Pulumi and AWS (Part 2)</title><link>https://yvesdenis.github.io/post/build-serverless-system-part-2-post/</link><pubDate>Sun, 15 Jan 2023 12:16:46 -0500</pubDate><guid>https://yvesdenis.github.io/post/build-serverless-system-part-2-post/</guid><description>Introduction In our previous article, we focused on the lambda-Sync part of our serverless system which corresponds to the synchronous part of our application.
We had already set up our entire continuous integration pipeline consisting of Github for the VCS, Codebuild to build our docker images and finally Cloudformation to deploy our resources in the AWS environment.
For this second part, there is no need to reinvent the wheel. We will use the instruments already in place and implement our asynchronous circuit.</description></item><item><title>Build serverless system with Pulumi and AWS (Part 1)</title><link>https://yvesdenis.github.io/post/build-serverless-system-part-1-post/</link><pubDate>Mon, 02 Jan 2023 08:13:08 -0400</pubDate><guid>https://yvesdenis.github.io/post/build-serverless-system-part-1-post/</guid><description>Introduction In my journey in the cloud and in the preparation of cloud certifications, I have been inspired by the AWS workshops carried out and generously made available to everyone by the AWS team.
This workshop which deals with the implementation of a serverless system is a must for all aspiring cloud engineers. It covers both the event-driven approach and the synchronous web-server mechanism.
In this post, we are working to resume the basic concept but bringing a DevOps concept with a pipeline to automate our deployments and also adding a front-end part also deployed in an automated way in the cloud.</description></item><item><title>Build, deploy and run an application with ECR, ECS and Codebuild (Part 2)</title><link>https://yvesdenis.github.io/post/ecs-ecr-codebuild-part-2-post/</link><pubDate>Sun, 18 Dec 2022 11:20:08 -0400</pubDate><guid>https://yvesdenis.github.io/post/ecs-ecr-codebuild-part-2-post/</guid><description>Introduction This is the second part of our project including ECS, ECR, Codebuild, github actions. You can find the first part here.
This part will focus more on the deployment of our application (its container image), the unit tests executed by Codebuild at each push in github and finally we can test through our web browser if our application responds as expected.
The source code of the whole project : https://github.</description></item><item><title>Build, deploy and run an application with ECR, ECS and Codebuild (Part 1)</title><link>https://yvesdenis.github.io/post/ecs-ecr-codebuild-part-1-post/</link><pubDate>Sun, 11 Dec 2022 11:20:08 -0400</pubDate><guid>https://yvesdenis.github.io/post/ecs-ecr-codebuild-part-1-post/</guid><description>Introduction In this article, we will follow the complete development cycle of a real-world application from its conception to its production. Nowadays, the wind of the moment pushes us all to turn to the cloud because in many aspects it offers more advantages compared to on-premises systems.
I decided to divide this tutorial into two parts given its volume, so for this first part, we will focus in more detail on the infrastructure to be deployed and the motivation behind the choice of technologies used.</description></item></channel></rss>